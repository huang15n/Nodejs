# Fichier des Opérations Spécifiques

Ce sujet présente les opérations les plus courantes utilisées en Node.js pour la gestion des fichiers, des chemins, du système d'exploitation, et plus encore. Vous y trouverez des exemples d'utilisation de modules essentiels tels que `os`, `path`, `fs`, et d'autres.

Voici un tableau récapitulatif des fonctions utilisées dans votre code avec une brève description de chacune :
Voici un tableau récapitulatif des fonctions que nous avons abordées dans les modules **`fs`**, **`os`**, **`path`**, et **`process`**. Ce tableau inclut une brève explication de chaque fonction et son usage :

### Module `fs` (Système de fichiers)

| Fonction               | Description                                                                  | Usage                                                                     |
| ---------------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| `fs.writeFile`         | Écrit des données dans un fichier. Si le fichier n'existe pas, il est créé.  | Utilisé pour écrire du contenu dans un fichier.                           |
| `fs.appendFile`        | Ajoute du contenu à un fichier existant sans écraser son contenu.            | Utilisé pour ajouter des données à la fin d'un fichier.                   |
| `fs.readFile`          | Lit le contenu d'un fichier. Retourne le contenu dans un callback.           | Utilisé pour lire les données d'un fichier.                               |
| `fs.copyFile`          | Copie un fichier d'un emplacement à un autre.                                | Utilisé pour copier des fichiers.                                         |
| `fs.rename`            | Renomme ou déplace un fichier ou un répertoire.                              | Utilisé pour renommer ou déplacer un fichier.                             |
| `fs.unlink`            | Supprime un fichier.                                                         | Utilisé pour supprimer un fichier.                                        |
| `fs.mkdir`             | Crée un répertoire (dossier).                                                | Utilisé pour créer un répertoire.                                         |
| `fs.rmdir`             | Supprime un répertoire vide.                                                 | Utilisé pour supprimer un répertoire vide.                                |
| `fs.createReadStream`  | Crée un flux de lecture pour lire des fichiers de manière asynchrone.        | Utilisé pour lire des fichiers de manière efficace en utilisant des flux. |
| `fs.createWriteStream` | Crée un flux d'écriture pour écrire dans des fichiers de manière asynchrone. | Utilisé pour écrire dans un fichier de manière efficace.                  |
| `fs.existsSync`        | Vérifie si un fichier ou répertoire existe de manière synchrone.             | Utilisé pour vérifier l'existence d'un fichier ou d'un dossier.           |

### Module `os` (Système d'exploitation)

| Fonction               | Description                                                               | Usage                                                                          |
| ---------------------- | ------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| `os.platform`          | Renvoie le nom de la plateforme du système d'exploitation.                | Utilisé pour détecter le système d'exploitation (ex : `win32`, `linux`, etc.). |
| `os.arch`              | Renvoie l'architecture du processeur du système d'exploitation.           | Utilisé pour obtenir l'architecture du processeur (ex : `x64`).                |
| `os.freemem`           | Renvoie la quantité de mémoire libre disponible sur le système en octets. | Utilisé pour surveiller la mémoire libre du système.                           |
| `os.totalmem`          | Renvoie la quantité totale de mémoire du système en octets.               | Utilisé pour connaître la mémoire totale du système.                           |
| `os.hostname`          | Renvoie le nom d'hôte du système.                                         | Utilisé pour obtenir le nom de la machine (ex : nom du serveur).               |
| `os.cpus`              | Renvoie les informations sur les CPU du système.                          | Utilisé pour obtenir des informations sur les processeurs du système.          |
| `os.networkInterfaces` | Renvoie les interfaces réseau du système.                                 | Utilisé pour obtenir les interfaces réseau disponibles.                        |

### Module `path` (Gestion des chemins)

| Fonction          | Description                                                           | Usage                                                                      |
| ----------------- | --------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| `path.join`       | Joint plusieurs segments de chemin pour créer un chemin absolu.       | Utilisé pour combiner des chemins de manière portable.                     |
| `path.resolve`    | Résout un chemin absolu à partir des segments de chemin donnés.       | Utilisé pour obtenir un chemin absolu à partir de chemins relatifs.        |
| `path.extname`    | Renvoie l'extension d'un fichier à partir de son nom de chemin.       | Utilisé pour obtenir l'extension d'un fichier.                             |
| `path.basename`   | Renvoie le nom de base d'un fichier à partir de son chemin.           | Utilisé pour obtenir le nom de fichier sans son chemin complet.            |
| `path.dirname`    | Renvoie le répertoire d'un fichier à partir de son chemin.            | Utilisé pour obtenir le répertoire d'un fichier sans son nom.              |
| `path.isAbsolute` | Vérifie si un chemin est absolu.                                      | Utilisé pour tester si un chemin est absolu ou relatif.                    |
| `path.normalize`  | Normalise un chemin en résolvant les points de référence (`..`, `.`). | Utilisé pour simplifier et normaliser les chemins de fichiers.             |
| `path.relative`   | Renvoie le chemin relatif entre deux chemins donnés.                  | Utilisé pour obtenir un chemin relatif entre deux fichiers ou répertoires. |

### Module `process` (Gestion du processus Node.js)

| Fonction         | Description                                                                                          | Usage                                                                             |
| ---------------- | ---------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| `process.exit`   | Termine le processus Node.js avec un code de sortie spécifié.                                        | Utilisé pour arrêter l'exécution du programme Node.js.                            |
| `process.on`     | Permet d'écouter les événements du processus, comme les erreurs non capturées (`uncaughtException`). | Utilisé pour gérer des événements système (ex : erreurs, fin du programme).       |
| `process.argv`   | Tableau contenant les arguments passés à Node.js en ligne de commande.                               | Utilisé pour récupérer les arguments de la ligne de commande.                     |
| `process.env`    | Contient les variables d'environnement du système d'exploitation.                                    | Utilisé pour accéder aux variables d'environnement (ex : `process.env.NODE_ENV`). |
| `process.uptime` | Renvoie le temps écoulé depuis le lancement du processus en secondes.                                | Utilisé pour mesurer la durée d'exécution du programme.                           |

---

Ce tableau récapitule les fonctions essentielles de ces modules et leurs usages typiques dans le développement avec Node.js.

## Asynchronisme

L'asynchronisme est une manière de gérer l'exécution des opérations dans un programme où certaines tâches peuvent prendre du temps à se terminer, comme :

Lire ou écrire dans un fichier.
Interroger une base de données.
Effectuer une requête réseau.

Dans les environnements asynchrones, comme Node.js, le programme continue d'exécuter d'autres instructions pendant qu'une opération longue (par exemple, l'écriture dans un fichier) est en cours. Cela permet d'améliorer les performances et d'éviter de bloquer tout le programme sur une seule tâche.

Prenons un scénario où vous écrivez du contenu dans un fichier, puis vous souhaitez ajouter du contenu supplémentaire. Si vous exécutez les deux opérations l'une après l'autre sans attendre la fin de la première

```js
const fs = require("fs");
const path = require("path");

console.log("Continuer...");

fs.writeFile(
  path.join(__dirname, "fichier", "nouvelle_fichier.txt"),
  `Enchanté de vous rencontrer à ${new Date()}`,
  { encoding: "utf-8" },
  (err) => {
    // Nous n'avons pas besoin de données ici, si une erreur survient, nous la lançons
    if (err) throw err;
    console.log("Écriture terminée !");
  }
);

// Utilisation correcte de path.join et de fs.readFile
fs.readFile(
  path.join(__dirname, "fichier", "nouvelle_fichier.txt"),
  "utf-8",
  (err, data) => {
    // Si une erreur survient, nous la lançons
    if (err) throw err;
    console.log("Contenu du fichier :", data);
  }
);

fs.appendFile(
  path.join(__dirname, "fichier", "nouvelle_fichier.txt"),
  `Ajout d'un message à ${new Date()}`,
  { encoding: "utf-8" },
  (err) => {
    // Si une erreur survient, nous la lançons
    if (err) throw err;
    console.log("Ajout terminé !");
  }
);

console.log("Continuer...");

// En raison de la nature asynchrone de Node.js
// La lecture du fichier est effectuée en dernier ici
// Si nous voulons modifier un fichier que nous venons de créer,
// Il serait préférable de mettre l'opération d'ajout (appendFile) juste après writeFile
// De cette façon, nous sommes certains que le fichier a été créé
// Et il sera prêt à être modifié sans risque de le remplacer

// Gestion des erreurs non capturées
process.on("uncaughtException", (err) => {
  console.error(`Il y a eu une erreur non capturée : ${err}`);
  process.exit(1);
});
```

Problème avec ce code :
Les deux opérations sont asynchrones.
Il n'est pas garanti que writeFile ait terminé avant que appendFile ne commence.
Si writeFile n'a pas fini de créer ou d'écrire dans le fichier, appendFile peut échouer car le fichier n'existe pas encore.

La fonction writeFile est asynchrone et prend un certain temps pour écrire le contenu.
En plaçant appendFile dans le callback de writeFile, on s'assure que l'écriture est terminée avant d'essayer d'ajouter du contenu.
Cela permet de synchroniser les opérations et d'éviter les conflits ou erreurs liées à l'exécution parallèle.
dans un environnement asynchrone comme Node.js, il est essentiel de gérer les dépendances entre les opérations. En insérant fs.appendFile dans le callback de fs.writeFile, vous contrôlez l'ordre d'exécution et évitez les erreurs.

```js

const fs = require("fs");
const path = require("path");

console.log("continuez.....");

// Créer ou écraser un fichier avec fs.writeFile
fs.writeFile(
  path.join(__dirname, "fichier", "nouvelle_fichier.txt"),
  `enchanté à vous rencontrer à ${new Date()}`, // Contenu initial du fichier
  { encoding: "utf-8" },
  (err) => {
    if (err) throw err; // En cas d'erreur lors de l'écriture, on interrompt le processus.

    console.log("Écriture terminée");

    // Placer fs.appendFile ici garantit que l'écriture initiale est terminée avant d'ajouter du contenu.
    // Node.js fonctionne de manière asynchrone, donc les opérations peuvent se chevaucher
    // si elles ne sont pas organisées correctement. Cela pourrait entraîner des problèmes comme
    // l'ajout de contenu avant la fin de l'écriture initiale.
    fs.appendFile(
      path.join(__dirname, "fichier", "nouvelle_fichier.txt"),
      `rajouter le message à ${new Date()}`, // Contenu supplémentaire ajouté après la création/écriture
      { encoding: "utf-8" },
      (err) => {
        if (err) throw err; // Gestion des erreurs pour l'ajout
        console.log("Ajout terminé");
      }
    );
  }
);

// Lire le fichier pour afficher son contenu
// Cette opération peut potentiellement s'exécuter avant la fin de fs.writeFile et fs.appendFile
// en raison de la nature asynchrone de Node.js.
fs.readFile(
  path.join(__dirname, "fichier", "nouvelle_fichier.txt"),
  "utf-8",
  (err, data) => {
    if (err) throw err; // Gestion des erreurs de lecture
    console.log(data); // Affiche le contenu actuel du fichier


```

## **Qu'est-ce que le Callback Hell ?**

Le pyramide de la mort est une situation où plusieurs fonctions asynchrones sont imbriquées les unes dans les autres, formant une structure pyramidale difficile à lire, comprendre, maintenir et déboguer. Cela se produit souvent lorsqu'on utilise des callbacks (fonctions de rappel) pour exécuter des tâches asynchrones les unes après les autres.

Voici un exemple typique de callback hell :

```js
fs.writeFile("file.txt", "data", (err) => {
  if (err) throw err;
  fs.readFile("file.txt", "utf-8", (err, data) => {
    if (err) throw err;
    fs.appendFile("file.txt", "more data", (err) => {
      if (err) throw err;
      console.log("All operations complete");
    });
  });
});
```

Dans ce cas, chaque fonction dépend du résultat de la précédente. Cela crée une structure imbriquée difficile à suivre.

---

```js
const fs = require("fs"); // Module pour manipuler le système de fichiers
const path = require("path"); // Module pour travailler avec les chemins de fichiers et de répertoires

console.log("continuez..."); // Message affiché avant le début des opérations

// Création et écriture dans un fichier
fs.writeFile(
  path.join(__dirname, "fichier", "nouvelle_fichier.txt"), // Chemin du fichier à écrire
  `Enchanté de vous rencontrer à ${new Date()}`, // Contenu initial à écrire dans le fichier
  { encoding: "utf-8" }, // Option d'encodage en UTF-8
  (err) => {
    if (err) throw err; // Gestion des erreurs pendant l'écriture

    console.log("Écriture terminée"); // Confirmation que l'écriture est terminée

    // Ajout de contenu au fichier existant
    fs.appendFile(
      path.join(__dirname, "fichier", "nouvelle_fichier.txt"), // Chemin du fichier à modifier
      `\nMessage ajouté à ${new Date()}`, // Contenu à ajouter
      { encoding: "utf-8" }, // Option d'encodage en UTF-8
      (err) => {
        if (err) throw err; // Gestion des erreurs pendant l'ajout
        console.log("Ajout terminé"); // Confirmation que l'ajout est terminé
      }
    );

    // Copie du fichier vers un nouveau fichier
    fs.copyFile(
      path.join(__dirname, "fichier", "nouvelle_fichier.txt"), // Chemin du fichier source
      path.join(__dirname, "fichier", "nouvelle_fichier1.txt"), // Chemin du fichier de destination
      (err) => {
        if (err) throw err; // Gestion des erreurs pendant la copie
        console.log("Copie terminée"); // Confirmation que la copie est terminée
      }
    );

    // Renommage du fichier copié
    fs.rename(
      path.join(__dirname, "fichier", "nouvelle_fichier1.txt"), // Chemin du fichier à renommer
      path.join(__dirname, "fichier", "nouvelle_fichier2.txt"), // Nouveau nom du fichier
      (err) => {
        if (err) throw err; // Gestion des erreurs pendant le renommage
        console.log("Renommage terminé"); // Confirmation que le renommage est terminé
      }
    );
  }
);

// Lecture du contenu du fichier
fs.readFile(
  path.join(__dirname, "fichier", "nouvelle_fichier.txt"), // Chemin du fichier à lire
  "utf-8", // Encodage utilisé pour lire le fichier
  (err, data) => {
    if (err) throw err; // Gestion des erreurs pendant la lecture
    console.log(data); // Affiche le contenu du fichier dans la console
  }
);

console.log("continuez..."); // Message affiché pour montrer que le script continue

// Gestion des erreurs non capturées
process.on("uncaughtException", (err) => {
  console.error(`Il y a eu une erreur non capturée : ${err}`); // Message d'erreur
  process.exit(1); // Arrête le programme en cas d'erreur critique
});
```

le code montre un début de **Callback Hell**, bien que la situation ne soit pas encore extrême. Voici pourquoi :

1. **Niveau d’imbrication** :

   - Votre fonction `fs.writeFile` contient une série d'autres fonctions (`fs.appendFile`, `fs.copyFile`, et `fs.rename`).
   - Ces opérations sont toutes imbriquées et exécutées dans le callback de `writeFile`.

2. **Problèmes associés** :
   - **Lisibilité réduite** : Si votre code devient plus complexe, la structure pyramidale sera difficile à lire et à maintenir.
   - **Débogage compliqué** : En cas d'erreur dans une étape intermédiaire, il sera difficile d'isoler le problème.
   - **Non extensible** : Si vous voulez ajouter des étapes supplémentaires, le code deviendra rapidement illisible.

---

les codes contient un **début de Callback Hell**, car plusieurs fonctions imbriquées augmentent la complexité. Utiliser des Promises ou `async/await` améliore la lisibilité, simplifie la gestion des erreurs et rend le code plus maintenable.

## \*\*Promesses et `async/await`

Les **Promesses** et `async/await` sont des mécanismes permettant de gérer les opérations asynchrones en JavaScript. Ils sont essentiels pour éviter le **Callback Hell** et rendre le code plus lisible, compréhensible et facile à maintenir.

### **1. Promesses (Promises)**

Une **promesse** (Promise) est un objet représentant l'achèvement ou l'échec d'une opération asynchrone. Elle permet de gérer des actions qui ne se produisent pas immédiatement, mais à un moment donné dans le futur.

#### **Syntaxe des Promesses**

Une promesse a trois états possibles :

- **Pending (En attente)** : L'opération n'est pas encore terminée.
- **Resolved (Résolue)** : L'opération est terminée avec succès.
- **Rejected (Rejetée)** : L'opération a échoué.

Voici un exemple de promesse avec `fs.promises` :

```js
const fs = require("fs").promises;

fs.readFile("file.txt", "utf-8")
  .then((data) => {
    console.log(data); // Si la promesse est résolue avec succès
  })
  .catch((err) => {
    console.error("Erreur :", err); // Si la promesse est rejetée (erreur)
  });
```

Dans cet exemple :

- **`fs.readFile`** renvoie une promesse.
- **`.then()`** permet de traiter la valeur retournée lorsque la promesse est résolue.
- **`.catch()`** permet de capturer et traiter une erreur si la promesse est rejetée.

#### **Exemple de chaîne de promesses :**

Si vous avez plusieurs actions asynchrones à réaliser, vous pouvez chaîner les promesses :

```js
fs.writeFile("file.txt", "Hello")
  .then(() => {
    return fs.appendFile("file.txt", " World");
  })
  .then(() => {
    return fs.readFile("file.txt", "utf-8");
  })
  .then((data) => {
    console.log(data); // Affiche "Hello World"
  })
  .catch((err) => {
    console.error("Erreur :", err);
  });
```

### **2. `async/await`**

**`async`** et **`await`** sont des syntaxes qui simplifient l'utilisation des promesses, rendant le code asynchrone plus facile à comprendre et à maintenir, comme du code synchrone.

- **`async`** : C'est un mot-clé qui marque une fonction comme étant asynchrone. Une fonction `async` renvoie toujours une promesse.
- **`await`** : C'est un mot-clé utilisé à l'intérieur des fonctions `async`. Il permet de "mettre en pause" l'exécution de la fonction jusqu'à ce que la promesse soit résolue.

#### **Exemple d'utilisation de `async/await`**

```js
const fs = require("fs").promises;

async function readFileAsync() {
  try {
    const data = await fs.readFile("file.txt", "utf-8");
    console.log(data); // Si la promesse est résolue
  } catch (err) {
    console.error("Erreur :", err); // Si la promesse est rejetée
  }
}

readFileAsync();
```

Ici :

- La fonction `readFileAsync` est marquée comme `async`, donc elle retourne une promesse.
- **`await`** est utilisé pour attendre que la promesse retournée par `fs.readFile` soit résolue avant de continuer l'exécution du code.

#### **Exemple de chaîne avec `async/await`**

```js
async function fileOperations() {
  try {
    await fs.writeFile("file.txt", "Hello");
    await fs.appendFile("file.txt", " World");
    const data = await fs.readFile("file.txt", "utf-8");
    console.log(data); // Affiche "Hello World"
  } catch (err) {
    console.error("Erreur :", err);
  }
}

fileOperations();
```

Dans cet exemple :

- **`await`** permet de s'assurer que chaque opération (écriture, ajout, lecture) est effectuée de manière séquentielle, comme si c'était du code synchrone.
- Si une erreur survient pendant l'exécution d'une des promesses, l'exécution est immédiatement arrêtée et l'erreur est capturée dans le bloc `catch`.

### **Avantages de `async/await` par rapport aux Promesses**

1. **Lisibilité améliorée** :

   - `async/await` ressemble davantage à du code synchrone, ce qui le rend plus facile à lire et à comprendre.
   - Il n'est plus nécessaire de chaîner plusieurs `.then()` et `.catch()`, ce qui simplifie la gestion des erreurs.

2. **Gestion des erreurs simplifiée** :

   - Avec `async/await`, vous pouvez utiliser un simple `try/catch` pour gérer les erreurs, ce qui est plus intuitif qu'avec les promesses où vous devez chaîner `.catch()`.

3. **Moins de structure imbriquée** :
   - Contrairement au **callback hell**, `async/await` permet d'éviter les fonctions imbriquées, rendant le code plus plat et plus facile à maintenir.

### **Quand utiliser `async/await` ?**

Utilisez **`async/await`** quand vous voulez simplifier et rendre le code asynchrone plus lisible, surtout lorsque vous avez plusieurs opérations asynchrones à effectuer en séquence.

### **Quand utiliser des Promesses ?**

Utilisez **des promesses** lorsque vous devez gérer des actions asynchrones en parallèle ou quand vous utilisez des API qui ne supportent pas encore `async/await` (bien que cela soit de moins en moins courant).

---

Voici un tableau résumant les fonctions que vous avez utilisées avec leurs usages respectifs :

| **Fonction**             | **Module**    | **Description**                                                     | **Usage dans le Code**                                                                                               |
| ------------------------ | ------------- | ------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| `fsPromise.writeFile()`  | `fs.promises` | Écrit des données dans un fichier, remplaçant son contenu existant. | Écrire une chaîne de caractères dans le fichier `nouvelle_fichier.txt` avec la valeur de `data` et la date actuelle. |
| `fsPromise.appendFile()` | `fs.promises` | Ajoute des données à la fin d'un fichier existant.                  | Ajouter du texte à la fin du fichier `nouvelle_fichier.txt`.                                                         |
| `fsPromise.copyFile()`   | `fs.promises` | Copie un fichier à un nouvel emplacement.                           | Copier le fichier `nouvelle_fichier.txt` vers `nouvelle_fichier1.txt`.                                               |
| `fsPromise.rename()`     | `fs.promises` | Renomme un fichier ou un répertoire.                                | Renommer `nouvelle_fichier1.txt` en `nouvelle_fichier2.txt`.                                                         |
| `fsPromise.readFile()`   | `fs.promises` | Lit le contenu d'un fichier de manière asynchrone.                  | Lire le contenu du fichier `nouvelle_fichier.txt` et le stocker dans `data`.                                         |
| `fsPromise.unlink()`     | `fs.promises` | Supprime un fichier du système de fichiers.                         | Supprimer le fichier `nouvelle_fichier2.txt` après avoir effectué toutes les opérations.                             |

```js
const fsPromise = require("fs").promises; // Module fs avec les méthodes retournant des Promesses pour manipuler le système de fichiers
const path = require("path"); // Module path pour gérer les chemins de fichiers et répertoires

console.log("continuez..."); // Affichage d'un message avant le début des opérations

// Fonction asynchrone pour gérer plusieurs opérations sur les fichiers
const fileOps = async () => {
  try {
    let data = `123456`; // Déclaration et initialisation de la variable 'data'

    console.log(data); // Affichage de la variable 'data' dans la console
    // Écriture de données dans le fichier 'nouvelle_fichier.txt'
    await fsPromise.writeFile(
      path.join(__dirname, "fichier", "nouvelle_fichier.txt"), // Chemin complet du fichier
      `${data} c'est nouvelle maintenant ${new Date()}` // Contenu à écrire, avec la valeur de 'data' et la date actuelle
    );

    // Ajout de contenu au fichier 'nouvelle_fichier.txt'
    await fsPromise.appendFile(
      path.join(__dirname, "fichier", "nouvelle_fichier.txt"), // Chemin du fichier à modifier
      `\n \nencore, c'est moi` // Contenu à ajouter avec des retours à la ligne
    );

    // Copie du fichier 'nouvelle_fichier.txt' vers 'nouvelle_fichier1.txt'
    await fsPromise.copyFile(
      path.join(__dirname, "fichier", "nouvelle_fichier.txt"), // Chemin du fichier source
      path.join(__dirname, "fichier", "nouvelle_fichier1.txt") // Chemin du fichier de destination
    );

    // Renommage du fichier 'nouvelle_fichier1.txt' en 'nouvelle_fichier2.txt'
    await fsPromise.rename(
      path.join(__dirname, "fichier", "nouvelle_fichier1.txt"), // Chemin du fichier à renommer
      path.join(__dirname, "fichier", "nouvelle_fichier2.txt") // Nouveau nom du fichier
    );

    // Lecture du contenu du fichier 'nouvelle_fichier.txt'
    data = await fsPromise.readFile(
      path.join(__dirname, "fichier", "nouvelle_fichier.txt"), // Chemin du fichier à lire
      "utf-8" // Encodage utilisé pour lire le fichier
    );

    // Suppression du fichier 'nouvelle_fichier2.txt' après les opérations
    await fsPromise.unlink(
      path.join(__dirname, "fichier", "nouvelle_fichier2.txt") // Chemin du fichier à supprimer
    );
  } catch (err) {
    console.error(err); // Si une erreur survient, elle est affichée dans la console
  }
};

// Appel de la fonction 'fileOps' pour exécuter les opérations
fileOps();

// Création et écriture dans un fichier
// fs.writeFile(
//   path.join(__dirname, "fichier", "nouvelle_fichier.txt"), // Chemin du fichier à écrire
//   `Enchanté de vous rencontrer à ${new Date()}`, // Contenu initial à écrire dans le fichier
//   { encoding: "utf-8" }, // Option d'encodage en UTF-8
//   (err) => {
//     if (err) throw err; // Gestion des erreurs pendant l'écriture

//     console.log("Écriture terminée"); // Confirmation que l'écriture est terminée

//     // Ajout de contenu au fichier existant
//     fs.appendFile(
//       path.join(__dirname, "fichier", "nouvelle_fichier.txt"), // Chemin du fichier à modifier
//       `\nMessage ajouté à ${new Date()}`, // Contenu à ajouter
//       { encoding: "utf-8" }, // Option d'encodage en UTF-8
//       (err) => {
//         if (err) throw err; // Gestion des erreurs pendant l'ajout
//         console.log("Ajout terminé"); // Confirmation que l'ajout est terminé
//       }
//     );

//     // Copie du fichier vers un nouveau fichier
//     fs.copyFile(
//       path.join(__dirname, "fichier", "nouvelle_fichier.txt"), // Chemin du fichier source
//       path.join(__dirname, "fichier", "nouvelle_fichier1.txt"), // Chemin du fichier de destination
//       (err) => {
//         if (err) throw err; // Gestion des erreurs pendant la copie
//         console.log("Copie terminée"); // Confirmation que la copie est terminée
//       }
//     );

//     // Renommage du fichier copié
//     fs.rename(
//       path.join(__dirname, "fichier", "nouvelle_fichier1.txt"), // Chemin du fichier à renommer
//       path.join(__dirname, "fichier", "nouvelle_fichier2.txt"), // Nouveau nom du fichier
//       (err) => {
//         if (err) throw err; // Gestion des erreurs pendant le renommage
//         console.log("Renommage terminé"); // Confirmation que le renommage est terminé
//       }
//     );
//   }
// );

// // Lecture du contenu du fichier
// fs.readFile(
//   path.join(__dirname, "fichier", "nouvelle_fichier.txt"), // Chemin du fichier à lire
//   "utf-8", // Encodage utilisé pour lire le fichier
//   (err, data) => {
//     if (err) throw err; // Gestion des erreurs pendant la lecture
//     console.log(data); // Affiche le contenu du fichier dans la console
//   }
// );

// console.log("continuez..."); // Message affiché pour montrer que le script continue

// Gestion des erreurs non capturées
process.on("uncaughtException", (err) => {
  console.error(`Il y a eu une erreur non capturée : ${err}`); // Message d'erreur
  process.exit(1); // Arrête le programme en cas d'erreur critique
});
```

- Toutes ces fonctions utilisent des **promesses**, ce qui signifie que vous pouvez les exécuter de manière asynchrone tout en garantissant un contrôle plus précis sur l’ordre des opérations avec `async/await`.
- **`try/catch`** est utilisé pour gérer les erreurs de manière élégante dans les fonctions asynchrones, afin d'éviter de laisser passer des exceptions non gérées.

Pour éviter le **Callback Hell** en JavaScript, vous pouvez adopter des techniques qui permettent de gérer plus facilement l'exécution asynchrone, comme les **Promesses**, l'**Async/Await** ou l'utilisation d'outils de gestion de flux asynchrones comme **Promise.all()**. Ces méthodes vous aident à organiser et à rendre votre code plus lisible, surtout lorsqu'il y a plusieurs niveaux de callbacks imbriqués.

Voici quelques stratégies pour éviter le **Callback Hell** :

### 1. **Utiliser des Promesses**

Les **Promesses** permettent de gérer les résultats asynchrones de manière plus propre et linéaire. Les Promesses vous permettent de chaîner les opérations de manière séquentielle, sans imbriquer les callbacks les uns dans les autres.

**Exemple avec Promesses :**

```javascript
const fsPromise = require("fs").promises;
const path = require("path");

fsPromise
  .writeFile(
    path.join(__dirname, "fichier", "fichier.txt"),
    "Données initiales"
  )
  .then(() => {
    return fsPromise.appendFile(
      path.join(__dirname, "fichier", "fichier.txt"),
      "\nAjout de texte"
    );
  })
  .then(() => {
    return fsPromise.copyFile(
      path.join(__dirname, "fichier", "fichier.txt"),
      path.join(__dirname, "fichier", "fichier_copie.txt")
    );
  })
  .then(() => {
    return fsPromise.rename(
      path.join(__dirname, "fichier", "fichier_copie.txt"),
      path.join(__dirname, "fichier", "fichier_renommé.txt")
    );
  })
  .catch((err) => {
    console.error("Une erreur est survenue :", err);
  });
```

Dans cet exemple, chaque opération est chaînée avec `.then()`. Si une erreur se produit à n'importe quel moment, elle est capturée par `.catch()`.

### 2. **Utiliser `async/await`**

L’utilisation de `async/await` est une autre approche qui permet d’écrire du code asynchrone de manière synchrone, améliorant ainsi la lisibilité et évitant les callbacks imbriqués.

**Exemple avec `async/await` :**

```javascript
const fsPromise = require("fs").promises;
const path = require("path");

const fileOps = async () => {
  try {
    await fsPromise.writeFile(
      path.join(__dirname, "fichier", "fichier.txt"),
      "Données initiales"
    );
    await fsPromise.appendFile(
      path.join(__dirname, "fichier", "fichier.txt"),
      "\nAjout de texte"
    );
    await fsPromise.copyFile(
      path.join(__dirname, "fichier", "fichier.txt"),
      path.join(__dirname, "fichier", "fichier_copie.txt")
    );
    await fsPromise.rename(
      path.join(__dirname, "fichier", "fichier_copie.txt"),
      path.join(__dirname, "fichier", "fichier_renommé.txt")
    );
  } catch (err) {
    console.error("Une erreur est survenue :", err);
  }
};

fileOps();
```

Avec `async/await`, le code devient plus linéaire et plus facile à suivre. Chaque opération est exécutée de manière séquentielle, mais sans avoir besoin de `then()` ou de nested callbacks.

### 3. **Utiliser `Promise.all()` pour les opérations parallèles**

Si vous devez exécuter plusieurs opérations asynchrones en parallèle, **`Promise.all()`** peut être utilisé pour éviter la création de multiples niveaux de callbacks imbriqués.

**Exemple avec `Promise.all()` :**

```javascript
const fsPromise = require("fs").promises;
const path = require("path");

const fileOps = async () => {
  try {
    // Lancer les opérations en parallèle
    await Promise.all([
      fsPromise.writeFile(
        path.join(__dirname, "fichier", "fichier.txt"),
        "Données initiales"
      ),
      fsPromise.appendFile(
        path.join(__dirname, "fichier", "fichier.txt"),
        "\nAjout de texte"
      ),
    ]);
    console.log("Écriture et ajout réussis");

    await Promise.all([
      fsPromise.copyFile(
        path.join(__dirname, "fichier", "fichier.txt"),
        path.join(__dirname, "fichier", "fichier_copie.txt")
      ),
      fsPromise.rename(
        path.join(__dirname, "fichier", "fichier_copie.txt"),
        path.join(__dirname, "fichier", "fichier_renommé.txt")
      ),
    ]);
    console.log("Copie et renommage réussis");
  } catch (err) {
    console.error("Une erreur est survenue :", err);
  }
};

fileOps();
```

`Promise.all()` permet d'exécuter plusieurs opérations en parallèle et attend que toutes les Promesses soient résolues. Cela peut être utile si les opérations ne dépendent pas les unes des autres.

### 4. **Utiliser des fonctions séparées**

Plutôt que d’imbriquer des fonctions ou des callbacks directement, vous pouvez séparer les différentes opérations dans des fonctions autonomes. Cela permet de mieux organiser le code.

**Exemple avec des fonctions séparées :**

```javascript
const fsPromise = require("fs").promises;
const path = require("path");

const writeToFile = async () => {
  await fsPromise.writeFile(
    path.join(__dirname, "fichier", "fichier.txt"),
    "Données initiales"
  );
};

const appendToFile = async () => {
  await fsPromise.appendFile(
    path.join(__dirname, "fichier", "fichier.txt"),
    "\nAjout de texte"
  );
};

const copyFile = async () => {
  await fsPromise.copyFile(
    path.join(__dirname, "fichier", "fichier.txt"),
    path.join(__dirname, "fichier", "fichier_copie.txt")
  );
};

const renameFile = async () => {
  await fsPromise.rename(
    path.join(__dirname, "fichier", "fichier_copie.txt"),
    path.join(__dirname, "fichier", "fichier_renommé.txt")
  );
};

const fileOps = async () => {
  try {
    await writeToFile();
    await appendToFile();
    await copyFile();
    await renameFile();
  } catch (err) {
    console.error("Une erreur est survenue :", err);
  }
};

fileOps();
```

Ici, chaque tâche est isolée dans une fonction distincte, ce qui rend le code plus modulaire et facile à comprendre.

### Résumé des solutions :

- **Promesses et `async/await`** : Ces outils permettent de gérer les opérations asynchrones de manière plus linéaire et lisible.
- **`Promise.all()`** : Utilisé pour exécuter plusieurs opérations asynchrones en parallèle.
- **Fonctions séparées** : En divisant les opérations en plusieurs fonctions, vous simplifiez la gestion des erreurs et la lisibilité.

Ces stratégies permettent de rendre le code plus facile à maintenir, à comprendre et à déboguer.

Voici comment vous pouvez organiser cette explication dans une section de votre fichier `README.md` :

````markdown
## Utilisation des flux en Node.js avec `createReadStream` et `createWriteStream`

Node.js offre des méthodes pratiques pour gérer la lecture et l’écriture de fichiers de manière **asynchrone** et en **flux** (stream). Ces méthodes permettent de traiter des fichiers de manière efficace en termes de mémoire, particulièrement utile pour les fichiers volumineux.

### 1. `createReadStream(path[, options])`

La méthode `createReadStream` est utilisée pour lire un fichier en **flux**. Au lieu de charger tout le fichier en mémoire d'un coup, elle lit le fichier morceau par morceau (par défaut, chaque morceau fait 64 Ko), ce qui permet de traiter de grands fichiers de manière efficace.

#### Arguments :

- **`path`** : Le chemin du fichier à lire.
- **`options`** (facultatif) : Un objet qui permet de spécifier des options comme :
  - `encoding` : L'encodage des données (par exemple `"utf-8"`).
  - `highWaterMark` : Taille du morceau (chunk) à lire, par défaut 64 Ko.

#### Exemple d’utilisation :

```javascript
const fs = require("fs");

const lire = fs.createReadStream("fichier.txt", { encoding: "utf-8" });

lire.on("data", (chunk) => {
  console.log("Données lues :", chunk);
});
```
````

#### Pourquoi l’utiliser ?

- **Efficacité mémoire** : La lecture en flux permet de traiter de grands fichiers sans les charger complètement en mémoire, ce qui évite les problèmes de mémoire.
- **Asynchrone** : La méthode est asynchrone, ce qui signifie que le programme peut continuer à exécuter d'autres tâches pendant que le fichier est en cours de lecture.
- **Traitement des fichiers volumineux** : Si vous travaillez avec de très gros fichiers (par exemple, des fichiers de log ou des vidéos), vous pouvez lire et traiter les données en continu sans charger le fichier en entier.

### 2. `createWriteStream(path[, options])`

La méthode `createWriteStream` permet d'écrire des données dans un fichier de manière **asynchrone** et en **flux**. Cela permet d'écrire progressivement dans un fichier, en évitant de devoir charger toutes les données en mémoire avant de commencer l’écriture.

#### Arguments :

- **`path`** : Le chemin du fichier où écrire.
- **`options`** (facultatif) : Un objet pour spécifier des options comme :
  - `encoding` : L'encodage des données (par exemple `"utf-8"`).
  - `flags` : Comment le fichier doit être ouvert (par exemple, `"w"` pour l’écriture ou `"a"` pour l’ajout).
  - `mode` : Les permissions à appliquer au fichier.

#### Exemple d’utilisation :

```javascript
const fs = require("fs");

const ecrire = fs.createWriteStream("fichier.txt", { encoding: "utf-8" });

ecrire.write("Bonjour, ceci est un test.\n");
ecrire.write("L'écriture continue...");
ecrire.end(); // Ferme le flux après l'écriture
```

#### Pourquoi l’utiliser ?

- **Efficacité mémoire** : Comme pour la lecture, l'écriture en flux permet de gérer de grandes quantités de données sans avoir besoin de tout stocker en mémoire.
- **Écriture asynchrone** : Le programme peut continuer à faire d’autres tâches pendant que l’écriture est en cours.
- **Prise en charge des fichiers volumineux** : Lors de l’écriture de gros fichiers, vous pouvez gérer l’écriture par morceaux, ce qui est plus rapide et plus économique en mémoire.

### 3. Utilisation combinée de `pipe`

La méthode **`pipe()`** permet de connecter directement un flux de lecture à un flux d’écriture, ce qui rend l’opération de lecture et d’écriture encore plus simple et efficace.

#### Exemple avec `pipe()` :

```javascript
const fs = require("fs");

const lire = fs.createReadStream("fichier.txt", { encoding: "utf-8" });
const ecrire = fs.createWriteStream("fichier_copie.txt", { encoding: "utf-8" });

lire.pipe(ecrire); // Copie du contenu de "fichier.txt" dans "fichier_copie.txt"
```

#### Pourquoi utiliser `pipe()` ?

- **Simplicité** : `pipe()` simplifie l’enchaînement de plusieurs flux de données, en rendant le code plus lisible et plus concis.
- **Efficacité** : Le processus de lecture et d’écriture se fait en continu, sans nécessiter de stockage complet en mémoire.
- **Optimisation** : Cette méthode est idéale pour les opérations de transformation de données ou de copie de fichiers volumineux.

```js
const fs = require("fs");

const lire = fs.createReadStream(
  path.join(__dirname, "fichier", "exemple.txt", { encoding: "utf-8" })
);

const ecrire = fs.createWriteStream(
  path.join(__dirname, "fichier", "exemple.txt", { encoding: "utf-8" })
);

lire.on("data", (data) => {
  ecrire.write(data);
});

lire.pipe(ecrire);
```

Les méthodes createReadStream et createWriteStream en Node.js, associées à l'utilisation de pipe(), sont des outils puissants pour manipuler des fichiers de manière asynchrone et efficace en termes de mémoire. Elles sont particulièrement adaptées aux fichiers volumineux et aux opérations nécessitant un traitement continu des données.

### Fonction `fs.mkdir`

La fonction `fs.mkdir` permet de créer un répertoire (dossier) dans le système de fichiers. Elle prend deux arguments principaux :

1. **Chemin du répertoire** : Il s'agit du chemin où le répertoire sera créé. Si le chemin est relatif, il sera résolu par rapport au répertoire actuel de l'exécution du script.
2. **Callback** : Une fonction qui sera appelée une fois l'opération terminée. Si une erreur survient pendant la création du répertoire, celle-ci sera passée en paramètre de la fonction de rappel. Si la création réussit, le dossier sera créé à l'emplacement spécifié.

### Fonction `fs.rmdir`

La fonction `fs.rmdir` est utilisée pour supprimer un répertoire vide. Elle prend également deux arguments :

1. **Chemin du répertoire** : Le chemin vers le répertoire à supprimer. Celui-ci doit être vide pour que la suppression soit réussie.
2. **Callback** : Une fonction qui est exécutée une fois l'opération terminée. Si une erreur se produit lors de la suppression, elle sera passée en paramètre de la fonction de rappel. En l'absence d'erreurs, le répertoire sera supprimé avec succès.

#### Points importants :

- **`fs.mkdir`** crée un répertoire. Si le répertoire existe déjà, une erreur sera levée.
- **`fs.rmdir`** supprime un répertoire, mais le répertoire doit être vide. Si le répertoire n'est pas vide, une erreur sera levée.
- Ces deux fonctions sont asynchrones, ce qui signifie qu'elles s'exécutent de manière non bloquante. Elles prennent donc un **callback** pour signaler la fin de l'opération.

```js
const fs = require("fs");

if (!fs.existsSync("./nouvelle_doissier")) {
  fs.mkdir("nouvelle_doissier", (err) => {
    if (err) throw err;
    console.log("Dossier 'nouvelle_doissier' créé");
  });
} else {
  // Utilisation correcte de fs.rmdir avec un callback
  fs.rmdir("./nouvelle_doissier", (err) => {
    if (err) {
      console.error("Erreur lors de la suppression du dossier :", err);
    } else {
      console.log("Dossier 'nouvelle_doissier' supprimé");
    }
  });
}
```
