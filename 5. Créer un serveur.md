# Créer un serveur avec Node.js

Ce tutoriel vous guide à travers la création d'un serveur simple en utilisant Node.js. Le code que vous avez fourni est une bonne base pour comprendre comment cela fonctionne.

```js
const PORT = process.env.PORT || 3500;

const serveur = http.createServer((requette, reponse) => {
  console.log(`${requette.url} ${requette.method}`);
});

serveur.listen(PORT, () => {
  console.log(`Serveur en cours d'exécution sur le port ${PORT}`);
});
```

| **Fonction/Module**   | **Description**                                                     |
| --------------------- | ------------------------------------------------------------------- |
| `require("http")`     | Importer le module HTTP de Node.js pour créer un serveur.           |
| `http.createServer()` | Créer une instance de serveur pour gérer les requêtes et réponses.  |
| `serveur.listen()`    | Démarrer le serveur et écouter les requêtes sur un port spécifique. |

```js
const http = require("http");
const chemin = require("path");
const systemeFichier = require("fs");
const promessesFichiers = require("fs").promises; // Utilisation des promesses pour les opérations sur les fichiers

// Modules spécifiques
const journalEvenement = require("./log"); // Module pour gérer les journaux d'événements
const evenements = require("events"); // Module pour gérer les événements
const monEmetteur = new evenements.EventEmitter(); // Création d'un émetteur d'événements personnalisé

const PORT = process.env.PORT || 3500; // Définit le port du serveur (3500 par défaut)

const serveur = http.createServer((requete, reponse) => {
  console.log(`URL demandée : ${requete.url}, Méthode : ${requete.method}`);
});

// Démarrer le serveur et écouter sur le port défini
serveur.listen(PORT, () =>
  console.log(`Serveur en cours d'exécution sur le port ${PORT}`)
);
```

```html
<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bienvenue sur mon serveur Node.js</title>
  </head>
  <body>
    <h1>Bonjour !</h1>
    <p>Ceci est une page servie par Node.js.</p>
  </body>
</html>
```

| **Étape**                       | **Description**                                                                                           | **Code associé**                                                                            |
| ------------------------------- | --------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | --- | ---------------------------- |
| 1. Vérifier l'URL de la requête | Vérifie si l'URL correspond à la route principale (`/`) ou au fichier `index.html`.                       | `if (requete.url === "/"                                                                    |     | requete === "index.html") {` |
| 2. Définir le code de statut    | Définit le code de statut HTTP à `200` pour indiquer que la requête a été traitée avec succès.            | `reponse.statusCode = 200;`                                                                 |
| 3. Définir les en-têtes         | Définit les en-têtes de réponse pour indiquer que le contenu est de type HTML.                            | `reponse.setHeader("Content-Type", "text/html");`                                           |
| 4. Lire le fichier HTML         | Utilise `systemeFichier.readFile` pour lire le contenu de `index.html` depuis le système de fichiers.     | `systemeFichier.readFile(chemin.join(__dirname, "index.html"), "utf8", (erreur, data) => {` |
| 5. Vérifier les erreurs         | Gère les éventuelles erreurs pendant la lecture du fichier et répond avec un message approprié si besoin. | _(Gestion des erreurs omise dans votre exemple, mais elle est recommandée.)_                |
| 6. Envoyer la réponse           | Envoie le contenu lu (variable `data`) comme réponse au client.                                           | `reponse.end(data);`                                                                        |
| 7. Terminer la condition        | Termine le bloc conditionnel après avoir répondu.                                                         | `}`                                                                                         |

---

```js
const http = require("http");
const chemin = require("path");
const systemeFichier = require("fs");
const promessesFichiers = require("fs").promises; // Utilisation des promesses pour les opérations sur les fichiers

// Modules spécifiques
const journalEvenement = require("./log"); // Module pour gérer les journaux d'événements
const evenements = require("events"); // Module pour gérer les événements
const monEmetteur = new evenements.EventEmitter(); // Création d'un émetteur d'événements personnalisé

const PORT = process.env.PORT || 3500; // Définit le port du serveur (3500 par défaut)

const serveur = http.createServer((requete, reponse) => {
  console.log(`URL demandée : ${requete.url}, Méthode : ${requete.method}`);

  if (requete.url === "/" || requete === "index.html") {
    reponse.statusCode = 200;
    reponse.setHeader("Content-Type", "text/html");
    systemeFichier.readFile(
      chemin.join(__dirname, "index.html"),
      "utf8",
      (erreur, data) => {
        reponse.end(data);
      }
    );
  }
});

// Démarrer le serveur et écouter sur le port défini
serveur.listen(PORT, () =>
  console.log(`Serveur en cours d'exécution sur le port ${PORT}`)
);
```

Cela peut vous aider à comprendre chaque étape de la gestion d'une requête dans un serveur HTTP en Node.js.

### Tableau des Fonctions, Étapes et Exemples de Code

| **Étape**                              | **Fonction**                    | **Description**                                                                                            | **Exemple de code général**                                                                                                                                                                                       |
| -------------------------------------- | ------------------------------- | ---------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. Création du serveur HTTP**        | `http.createServer()`           | Crée un serveur HTTP qui écoute les requêtes et répond en fonction de celles-ci.                           | `const http = require('http');<br>const serveur = http.createServer((req, res) => {<br>  // traitement<br>});`                                                                                                    |
| **2. Configuration du code de statut** | `reponse.statusCode`            | Définit le code de statut HTTP de la réponse (par exemple, 404 pour "Page non trouvée", 200 pour OK).      | `reponse.statusCode = 404;`                                                                                                                                                                                       |
| **3. Configuration des en-têtes HTTP** | `reponse.setHeader()`           | Définie les en-têtes HTTP, par exemple le type de contenu de la réponse.                                   | `reponse.setHeader('Content-Type', 'text/html');`                                                                                                                                                                 |
| **4. Terminer la réponse**             | `reponse.end()`                 | Termine la réponse en envoyant les données au client. Cela peut inclure le contenu ou un message d'erreur. | `reponse.end('Page non trouvée.');`                                                                                                                                                                               |
| **5. Lire un fichier et répondre**     | `systemeFichier.readFile()`     | Lit un fichier local (par exemple, un fichier HTML) et envoie son contenu comme réponse.                   | `systemeFichier.readFile('chemin/vers/fichier.html', 'utf8', (err, data) => {<br>  reponse.end(data);<br>});`                                                                                                     |
| **6. Écouter le serveur**              | `serveur.listen()`              | Démarre le serveur pour écouter sur un port spécifique et exécute une fonction de rappel lorsque prêt.     | `serveur.listen(3500, () => {<br>  console.log('Serveur démarré');<br>});`                                                                                                                                        |
| **7. Gestion des erreurs**             | `try-catch` ou gestion d'erreur | Capture et gère les erreurs potentielles, par exemple si un fichier n'est pas trouvé.                      | `try {<br>  systemeFichier.readFile('inexistant.html', 'utf8', (err, data) => {<br>    if (err) throw err;<br>  });<br>} catch (error) {<br>  reponse.statusCode = 500;<br>  reponse.end('Erreur interne');<br>}` |

---

### Explication des étapes :

1. **Création du serveur HTTP (`http.createServer`) :**

   - Permet de définir un serveur qui écoute les requêtes HTTP. Il prend une fonction de rappel qui traite les requêtes entrantes et renvoie les réponses appropriées.

2. **Configuration du code de statut (`reponse.statusCode`) :**

   - Chaque réponse HTTP a un code de statut. Vous pouvez utiliser cette fonction pour définir le code de statut. Par exemple, un code 200 signifie que tout s'est bien passé, tandis qu'un code 404 signifie que la page demandée est introuvable.

3. **Configuration des en-têtes HTTP (`reponse.setHeader`) :**

   - Vous pouvez définir les en-têtes HTTP pour préciser des informations sur la réponse, comme le type de contenu (`Content-Type`). Cela indique au client quel type de données il peut attendre (texte, HTML, JSON, etc.).

4. **Terminer la réponse (`reponse.end`) :**

   - Lorsque vous avez fini de préparer la réponse, vous devez utiliser `end()` pour l'envoyer au client. Vous pouvez passer des données ou un message d'erreur comme argument.

5. **Lire un fichier et répondre (`systemeFichier.readFile`) :**

   - Si vous souhaitez envoyer un fichier comme réponse (par exemple, un fichier HTML), vous pouvez utiliser `readFile` pour lire le fichier. Une fois lu, vous envoyez son contenu via la réponse.

6. **Écouter le serveur (`serveur.listen`) :**

   - Permet au serveur d'écouter les requêtes entrantes sur un port spécifique (par exemple, `3500`). Vous pouvez inclure une fonction de rappel pour confirmer que le serveur fonctionne correctement.

7. **Gestion des erreurs (`try-catch`) :**
   - Utiliser `try-catch` pour gérer les erreurs qui peuvent survenir lors de la lecture d'un fichier ou d'autres processus. Par exemple, si un fichier est introuvable, vous pouvez renvoyer une erreur 500.

---

```js
const http = require("http");
const chemin = require("path");
const systemeFichier = require("fs");
const promessesFichiers = require("fs").promises; // Utilisation des promesses pour les opérations sur les fichiers

// Modules spécifiques
const journalEvenement = require("./log"); // Module pour gérer les journaux d'événements
const evenements = require("events"); // Module pour gérer les événements
const monEmetteur = new evenements.EventEmitter(); // Création d'un émetteur d'événements personnalisé

const PORT = process.env.PORT || 3500; // Définit le port du serveur (3500 par défaut)

// Création du serveur HTTP
const serveur = http.createServer((requete, reponse) => {
  // Affichage dans la console de l'URL demandée et de la méthode HTTP utilisée (GET, POST, etc.)
  console.log(`URL demandée : ${requete.url}, Méthode : ${requete.method}`);

  // Switch pour vérifier quelle URL est demandée
  switch (requete.url) {
    // Si la requête est pour la page d'accueil ou "index.html"
    case "/":
    case "/index.html":
      // Réponse avec un code HTTP 200 (OK) et un en-tête de type de contenu HTML
      reponse.statusCode = 200;
      reponse.setHeader("Content-Type", "text/html");

      // Lecture du fichier "index.html" et renvoi du contenu dans la réponse
      systemeFichier.readFile(
        chemin.join(__dirname, "index.html"), // Emplacement du fichier index.html
        "utf8", // Encodage du fichier
        (erreur, data) => {
          // Fonction de rappel pour traiter le fichier
          // Si une erreur survient lors de la lecture du fichier
          if (erreur) {
            // Si une erreur survient, renvoyer une erreur HTTP 500 (Erreur interne du serveur)
            reponse.statusCode = 500;
            reponse.end("Erreur interne du serveur.");
          } else {
            // Si le fichier est lu avec succès, renvoyer son contenu dans la réponse
            reponse.end(data);
          }
        }
      );
      break;

    // Si l'URL demandée n'est pas trouvée, renvoyer une erreur 404 (Page non trouvée)
    default:
      reponse.statusCode = 404;
      reponse.setHeader("Content-Type", "text/plain");
      reponse.end("Page non trouvée.");
      break;
  }
});

// Démarrer le serveur et écouter sur le port défini
serveur.listen(PORT, () =>
  console.log(`Serveur en cours d'exécution sur le port ${PORT}`)
);
```

L'instruction switch est utile pour gérer plusieurs cas différents dans une structure conditionnelle, mais elle peut ne pas être idéale dans certaines situations où vous devez effectuer des vérifications plus spécifiques ou complexes. Par exemple, lorsque vous devez déterminer le type de contenu à retourner en fonction de l'extension d'un fichier (comme .html, .css, .js, etc.), une approche plus flexible consiste à utiliser une variable pour gérer l'extension du fichier et ensuite déterminer le type de contenu.

```js
const http = require("http");
const chemin = require("path");
const systemeFichier = require("fs");
const promessesFichiers = require("fs").promises; // Utilisation des promesses pour les opérations sur les fichiers

// Modules spécifiques
const journalEvenement = require("./log"); // Module pour gérer les journaux d'événements
const evenements = require("events"); // Module pour gérer les événements
const monEmetteur = new evenements.EventEmitter(); // Création d'un émetteur d'événements personnalisé

const PORT = process.env.PORT || 3500;

const serveur = http.createServer((requette, reponse) => {
  console.log(`${requette.url} ${requette.method}`);

  const extension = chemin.extname(requette.url);

  let contenuType;

  switch (extension) {
    case ".html": // Si le fichier est un fichier HTML
      contenuType = "text/html";
      break;
    case ".css": // Si le fichier est un fichier CSS
      contenuType = "text/css";
      break;
    case ".js": // Si le fichier est un fichier JavaScript
      contenuType = "application/javascript";
      break;
    case ".json": // Si le fichier est un fichier JSON
      contenuType = "application/json";
      break;
    case ".jpg": // Si le fichier est une image JPG
    case ".jpeg": // Si le fichier est une image JPEG
      contenuType = "image/jpeg";
      break;
    case ".png": // Si le fichier est une image PNG
      contenuType = "image/png";
      break;
    default:
      contenuType = "text/html";
      break;
  }

  // Construire le chemin du fichier
  const cheminFichier = chemin.join(
    __dirname,
    requette.url === "/" ? "index.html" : requette.url
  );

  // Lire le fichier et le renvoyer à l'utilisateur
  systemeFichier.readFile(cheminFichier, "utf8", (erreur, data) => {
    if (erreur) {
      reponse.statusCode = 404;
      reponse.setHeader("Content-Type", "text/plain");
      reponse.end("Page non trouvée.");
      return;
    }
    reponse.statusCode = 200;
    reponse.setHeader("Content-Type", contenuType);
    reponse.end(data);
  });
});

serveur.listen(PORT, () => {
  console.log(`Serveur en cours d'exécution sur le port ${PORT}`);
});
```

Voici un tableau qui présente les différentes fonctions utilisées dans le code, leur objectif et leur usage :

| **Fonction**                | **Description**                                                                               | **Usage dans le code**                                                                                                                       |
| --------------------------- | --------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `systemeFichier.readFile()` | Lit un fichier de manière asynchrone.                                                         | Utilisé pour lire le fichier demandé par l'utilisateur. Le contenu est ensuite envoyé dans la réponse HTTP.                                  |
| `chemin.join()`             | Joint plusieurs segments de chemin de fichier en un seul chemin valide.                       | Utilisé pour construire le chemin du fichier demandé, que ce soit pour `index.html` ou d'autres fichiers statiques.                          |
| `requette.url`              | Accède à l'URL demandée par le client.                                                        | Utilisé pour obtenir l'URL de la requête afin de déterminer quel fichier demander (par exemple, `index.html` ou un fichier CSS/JS).          |
| `requette.method`           | Accède à la méthode HTTP de la requête (par exemple, GET, POST).                              | Utilisé pour afficher les informations de la requête, bien que dans ce code, la méthode ne soit pas utilisée.                                |
| `chemin.extname()`          | Renvoie l'extension du fichier à partir de son chemin.                                        | Utilisé pour déterminer le type de fichier (par exemple `.html`, `.css`, `.js`, etc.) et choisir le bon type MIME.                           |
| `reponse.statusCode`        | Définit le code de statut HTTP de la réponse (par exemple, 200 pour OK, 404 pour non trouvé). | Utilisé pour envoyer un code de statut HTTP approprié dans la réponse, en fonction du résultat de la lecture du fichier.                     |
| `reponse.setHeader()`       | Définit un en-tête HTTP pour la réponse.                                                      | Utilisé pour définir le type de contenu dans l'en-tête de la réponse (par exemple, `Content-Type: text/html` ou `Content-Type: image/jpeg`). |
| `reponse.end()`             | Envoie la réponse finale au client.                                                           | Utilisé pour envoyer la réponse complète, y compris le contenu du fichier ou un message d'erreur (par exemple, "Page non trouvée.").         |
| `try/catch`                 | Bloc pour gérer les exceptions (erreurs).                                                     | Utilisé pour capturer toute erreur survenue lors de la lecture du fichier et renvoyer une erreur 404 si le fichier n'est pas trouvé.         |

```js
const http = require("http");
const chemin = require("path");
const systemeFichier = require("fs").promises; // Utilisation des promesses pour la lecture des fichiers

// Dictionnaire des types MIME en fonction des extensions
const typesMIME = {
  ".html": "text/html",
  ".css": "text/css",
  ".js": "application/javascript",
  ".json": "application/json",
  ".jpg": "image/jpeg",
  ".jpeg": "image/jpeg",
  ".png": "image/png",
};

// Le port par défaut ou celui de l'environnement
const PORT = process.env.PORT || 3500;

const serveur = http.createServer(async (requette, reponse) => {
  console.log(`${requette.url} ${requette.method}`);

  const extension = chemin.extname(requette.url) || ".html"; // Extension du fichier demandé
  const contenuType = typesMIME[extension] || "text/html"; // Récupération du type MIME

  // Construire le chemin du fichier
  const cheminFichier = chemin.join(
    __dirname,
    requette.url === "/" ? "index.html" : requette.url
  );

  try {
    // Lire le fichier et renvoyer la réponse
    const data = await systemeFichier.readFile(cheminFichier, "utf8");
    reponse.statusCode = 200;
    reponse.setHeader("Content-Type", contenuType);
    reponse.end(data);
  } catch (erreur) {
    // En cas d'erreur, renvoyer une page 404
    reponse.statusCode = 404;
    reponse.setHeader("Content-Type", "text/plain");
    reponse.end("Page non trouvée.");
  }
});

serveur.listen(PORT, () => {
  console.log(`Serveur en cours d'exécution sur le port ${PORT}`);
});
```

```js
const http = require("http");
const chemin = require("path");
const systemeFichier = require("fs");
const promessesFichiers = require("fs").promises; // Utilisation des promesses pour les opérations sur les fichiers

const PORT = process.env.PORT || 3500;

// Définition des types MIME
const typesMIME = {
  ".html": "text/html",
  ".css": "text/css",
  ".js": "application/javascript",
  ".json": "application/json",
  ".jpg": "image/jpeg",
  ".jpeg": "image/jpeg",
  ".png": "image/png",
};

// Fonction pour servir un fichier
async function serveFile(filePath, contentType, response) {
  try {
    // Lecture du fichier
    const data = await promessesFichiers.readFile(filePath, "utf8");

    // Utilisation de writeHead pour envoyer le statut et les en-têtes
    response.writeHead(200, { "Content-Type": contentType });

    // Envoi du fichier
    response.end(data);
  } catch (erreur) {
    // En cas d'erreur, envoie une réponse 500 (erreur interne du serveur)
    console.error("Erreur lors de la lecture du fichier:", erreur);

    // Utilisation de writeHead pour envoyer le statut d'erreur et l'en-tête
    response.writeHead(500, { "Content-Type": "text/plain" });
    response.end("Erreur interne du serveur.");
  }
}

// Serveur HTTP
const serveur = http.createServer((requete, reponse) => {
  console.log(`${requete.url} ${requete.method}`);

  const extension = chemin.extname(requete.url);
  const contenuType = typesMIME[extension] || "text/html"; // Type MIME par défaut

  // Construire le chemin du fichier
  const cheminFichier = chemin.join(
    __dirname,
    requete.url === "/" ? "index.html" : requete.url
  );

  // Appel de la fonction serveFile pour gérer la demande de fichier
  serveFile(cheminFichier, contenuType, reponse);
});

serveur.listen(PORT, () => {
  console.log(`Serveur en cours d'exécution sur le port ${PORT}`);
});
```
